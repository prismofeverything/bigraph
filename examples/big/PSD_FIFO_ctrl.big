# the probabilisic extension of CAN Semantic Model from "Modelling and Verifying BDI Agents with Bigraphs. Xu et al"
# intention_step and other non-deterministc rules (e.g. plan selection) are normal rules 
# the rest of rules are instantenous rules
# the idea is that when an Reduce is added, 
# after the applications of all instantenous rules in the background, the next step is produced.  

## CONTROLS

ctrl Check = 0;
ctrl Del = 0;
ctrl Add = 0;
atomic ctrl T = 0; # true
atomic ctrl F = 0; # false

ctrl Intentions = 0;
ctrl Intent = 1;

ctrl Desires = 0;

ctrl Beliefs = 0;

# the belief atom is extended with two parameters
# first is to denote the product, i.e. m'th box
# the second is the actual belief atoms in the form of string.
atomic fun ctrl B(m,n) = 0;

ctrl Reduce = 0;
atomic ctrl ReduceF = 0;

ctrl Act = 0;
ctrl Pre = 0;

ctrl Event = 1;

# the status token is added.
atomic ctrl Idle = 0;
atomic ctrl Active = 0;
atomic ctrl Success = 0;
atomic ctrl Failure = 0;
atomic fun ctrl EId(n) = 0;
# declarative information for an event in the Desires
atomic fun ctrl Deadline(n) = 0;
atomic fun ctrl Progress(n) = 0;

# the Step(n) is introduced to count the step of the agent. 
atomic fun ctrl Step(n) = 0;


ctrl Plans = 0;
ctrl PlanSet = 1;
ctrl Plan = 0;
ctrl PB = 0;
atomic fun ctrl PId(n) = 0;

# Tree
ctrl Try = 0; #OR-Like
ctrl Seq = 0; #AND-Like
ctrl Cons = 0;

ctrl Conc = 0;
ctrl L = 0;
ctrl R = 0;


atomic ctrl CheckToken = 0;

ctrl Goal = 0;
ctrl SC = 0;
ctrl FC = 0;

# I need to add Nil to get away from some sutble problems for instantenous rules
# Nil for 1 
atomic ctrl Nil = 0;

# the sames reason to introduce Trys to get away from some sutble problems for instantenous rules
# detailed reason can be requested in person
# Try for special case:
ctrl Trys = 0;


# Synchronisation token
# this token is to serve as switch-off/on to update the deadline of the events
atomic ctrl DSync = 0;



# Preference
ctrl Preference = 0;
ctrl Situation = 0;
atomic fun ctrl PrefWeight(n) = 0;
atomic ctrl CalculationToken = 0;
atomic ctrl Original = 0;


# stochastic actions
ctrl Effect = 0;
atomic fun ctrl EffWeight(n) = 0;
## END Controls

# # # Product Wrapping and Moving Example
big pack_box_1_wrap_1 = Act.(Pre.1 | Effect.(Add.B(1,"packed") | Del.1 | EffWeight(1)));
big pack_box_1_wrap_2 = Act.(Pre.1 | Effect.(Add.B(1,"packed") | Del.1 | EffWeight(1)));
big deliver_box_1_wrap_1 = Act.(Pre.B(1,"packed") | Effect.(Add.B(1,"success") | Del.1 | EffWeight(9)) | Effect.(Add.B(1,"failure") | Del.1 | EffWeight(1)));
big deliver_box_1_wrap_2 = Act.(Pre.B(1,"packed") | Effect.(Add.B(1,"success") | Del.1 | EffWeight(1)));

big pack_box_2_wrap_1 = Act.(Pre.1 | Effect.(Add.B(2,"packed") | Del.1 | EffWeight(1)));
big pack_box_2_wrap_2 = Act.(Pre.1 | Effect.(Add.B(2,"packed") | Del.1 | EffWeight(1)));
big deliver_box_2_wrap_1 = Act.(Pre.B(2,"packed") | Effect.(Add.B(2,"success") | Del.1 | EffWeight(9)) | Effect.(Add.B(2,"failure") | Del.1 | EffWeight(1)));
big deliver_box_2_wrap_2 = Act.(Pre.B(2,"packed") | Effect.(Add.B(2,"success") | Del.1 | EffWeight(1)));

big two_products =
        Beliefs.1
     || Desires.(Event{ps1}.(EId(1) | Deadline(8) | Idle | Progress(0)) | Event{ps3}.(EId(2) | Deadline(12) | Idle | Progress(0)))
     || Intentions.1
     || Plans.(
            PlanSet{ps1}.Plan.(PId(0) | Original | Pre.1 | PB.Goal.(SC.B(1,"success") | Event{ps2}.1 | FC.B(1,"failure")) |  PrefWeight(1))
          | PlanSet{ps2}.(
                          Plan.(PId(1) | Original| Pre.B(1,"GEQ3") | PB.(Seq.(pack_box_1_wrap_1 | Cons.deliver_box_1_wrap_1)) | Preference.(Situation.B(1,"GEQ3") | PrefWeight(1)) | PrefWeight(1))
                        | Plan.(PId(2) | Original| Pre.B(1,"GEQ0") | PB.(Seq.(pack_box_1_wrap_2 | Cons.deliver_box_1_wrap_2)) | Preference.(Situation.B(1,"GEQ0LEQ2") | PrefWeight(1)) | PrefWeight(1)) 
                        ) 
          | PlanSet{ps3}.Plan.(PId(0) | Original | Pre.1 | PB.Goal.(SC.B(2,"success") | Event{ps4}.1 | FC.B(2,"failure")) | PrefWeight(1))
          | PlanSet{ps4}.(
                          Plan.(PId(1) | Original| Pre.B(2,"GEQ3") | PB.(Seq.(pack_box_2_wrap_1 | Cons.deliver_box_2_wrap_1)) | Preference.(Situation.B(2,"GEQ3") | PrefWeight(1)) | PrefWeight(1))
                        | Plan.(PId(2) | Original| Pre.B(2,"GEQ0") | PB.(Seq.(pack_box_2_wrap_2 | Cons.deliver_box_2_wrap_2)) | Preference.(Situation.B(2,"GEQ0LEQ2") | PrefWeight(1)) | PrefWeight(1))
                        ) 
          );

big box_1_failure = Event{ps1}.(id | EId(1) | Failure);
big box_1_success = Event{ps1}.(id | EId(1) | Success);
big box_2_failure = Event{ps4}.(id | EId(2) | Failure);
big box_2_success = Event{ps4}.(id | EId(2) | Success);
